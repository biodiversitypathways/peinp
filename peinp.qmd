---
title: "Report on the use of passive acoustic monitoring in Prince Edward Island National Park"
format:
  html:
    grid:
      margin-width: 300px
navbar: right
theme: cosmo
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Alex MacPhail"
editor: visual
bibliography: references.bib
nocite: '@*'
toc: true
toc-depth: 3
toc-expand: true
toc-location: left
styles: styles.css
reference-location: margin
citation-location: margin
---

![](peinpheader.png){style="float:left`;" fig-alt="Photo of the ocean" fig-align="center"}

<div style="background-color: #f4f4f4; padding: 20px;">
To run this report locally:

- Open RStudio or your preferred IDE
- Create a new project and set up for version control using the GitHub repository
- Pull from remote main
- Load the `pei.RData` file in the first chunk
- Render the document and review the results
</div>

```{r}
#| label: load-packages and authenticate
#| include: false
#| echo: false
#| eval: true
#| warning: false
#| message: false

library(tidyverse)
library(wildRtrax)
library(unmarked)
library(sf)
library(terra)
library(vctrs)
library(ggridges)
library(scales)
library(kableExtra)
library(plotly)
library(DT)
library(lme4)
library(ggpubr)
library(vegan)
library(MuMIn)
library(AICcmodavg)

wt_auth()

load('pei.RData')
#save.image('pei.RData')
#cirrus_penp_recs  <- readRDS('penpcirrus.RDS')
```

# Abstract

Passive acoustic monitoring has proven to be a valuable tool for monitoring vocalizing species. Environmental sensors are becoming increasingly easy to program and can autonomously generating extensive data sets of the soundscape, an invaluable resource for ecological integrity monitoring. Prince Edward Island National deployed autonomous recording units (ARUs) across `r pei_locs |> st_drop_geometry() |> select(location) |> distinct() |> tally()` locations during a comprehensive five-year survey. The analysis revealed that species richness and diversity remained relatively stable, while single-species occupancy exhibited diverse patterns. Common and generalist species showed consistent occupancy, but there was a notable reduction in conifer-nesting species in 2023, likely attributed to forest structural loss. Ongoing monitoring and dynamic models can yield more detailed and predictive results to ensure the continued maintenance of ecological integrity in the Park.

------------------------------------------------------------------------

# Land Acknowledgement

In the spirit of Reconciliation, we acknowledge that the land upon which this data was gathered is unceeded Mi'kmaq territory. Epekwitk (Prince Edward Island), Mi'kma'ki, is covered by the historic Treaties of Peace and Friendship. We pay our respects to the Indigenous Mi'kmaq People who have occupied this Island for over 12,000 years; past, present and future.

# Introduction

Human activities have been identified as key pressures and contributors to the global decline in forest wildlife (@allan2017recent). The repercussions of habitat fragmentation (@fahrig2003effects) and loss (@hanski2011habitat), climate change (@mantyka2012interactions, @sattar2021review, @abrahms2023climate), and increased access to sensitive areas exert direct and indirect pressures on forest biodiversity, particularly in managed regions in Canada (@lemieux2011state).

In 2019, Prince Edward Island National Park initiated a program incorporating autonomous recording units (ARUs) for passive acoustic monitoring (PAM) of the Park's wildlife. ARUs are compact environmental sensors that are designed to passively record the environment (@aru-overview), capturing vocalizing species like birds and amphibians, which is growing in use across the globe (@lots-of-pam). This technology enables resource managers to conduct prolonged surveys with minimal human interference. The subsequent data collected by these units contribute valuable information to ecological integrity metrics such as species richness, diversity, occupancy, and trends over time. This data aids decision-making and management within the Park. Given the rapid and ease of accumulating data from these units, maintaining a high standard of data integrity is paramount to ensure future data interoperability and sharing. [WildTrax](https://www.wildtrax.ca) is an online platform developed by the [Alberta Biodiversity Monitoring Institute (**ABMI**)](https://abmi.ca) for users of environmental sensors to help addresses these big data challenges by providing solutions to standardize, harmonize, and share data.

The objectives of this report are to:

-   Describe the data management and processing procedures for the acoustic data collected from 2019 to 2023;
-   Utilize traditional human tagging, visual scanning and automated recognition techniques to detect and count species and individuals heard on recordings;
-   Define straightforward methods for evaluating species presence, species richness, and species occupancy over time at various locations;
-   Offer recommendations for ongoing monitoring approaches to contribute to the assessment of ecological integrity in forest ecosystems;
-   Facilitate data publication to the public, resource managers, academic institutions, and any other relevant agencies

------------------------------------------------------------------------

# Methods

## Data collection

Data were collected during the spring and summer seasons from `r min(pei_locs$year)` to `r max(pei_locs$year)`. A total of `r pei_locs |> st_drop_geometry() |> select(location) |> distinct() |> tally()` locations were surveyed over the five-year period:

-   21 locations as part of the forest songbird monitoring program (code: `PENP-*`) with ARUs recording during the morning hours,
-   6 for Bank Swallow Monitoring (code: `PENP-BS-*`) with ARUs placed strategically beside ponds recording in the evening,
-   2 locations deployed in First Nations communities (`ASC-1, LXI-1`) to complement the forest songbird and evening schedules,
-   And one location (`PENP-E1`), which was to examine the effects of a single public event

Locations were surveyed on rotation with `r length(repeats)` locations (`r repeats`) surveyed each year. A detailed list of all survey years can be found in Table 1 (@tbl-loc-summary) and illustrated in Figure 1 (@fig-locs). ARUs were deployed at the beginning of the breeding season in April-May, and rotated locations until their final retrieval in July-August. At the forest songbird locations (`PENP-*`), the ARUs were set to record for 30 minutes continuously every hour for four hours, starting one hour before dawn and ending three hours after dawn. For Bank Swallow Monitoring locations (`PENP-BS`), recordings were made every 5 minutes for a duration of 3 minutes each from 1.5 hours before dusk to 1.5 hours after dusk. On average, each ARU recorded for `r average_deployment$mean` +/- `r average_deployment$sd` days.

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide

pei_locs <- pei_main |>
  mutate(year = lubridate::year(recording_date_time)) |>
  select(location, latitude, longitude, year) |>
  distinct() |>
  sf::st_as_sf(coords = c("longitude","latitude"), crs = 4326)

repeats <- pei_locs |>
  st_drop_geometry() |>
  group_by(location) |>
  summarise(count = n_distinct(year)) |>
  ungroup() |>
  filter(count == 5) |>
  select(location) |>
  distinct() |>
  pull()

######## Define geospatial assets

pei_shp <- read_sf('assets/PEI.shp')
peinp_shp <- read_sf('assets/peinp.shp')
peinp_shp <- st_transform(peinp_shp, st_crs(pei_locs)) |> st_make_valid()
#coast <- read_sf('assets/coastline_polygon.shp') 
#coast <- st_transform(coast, st_crs(pei_locs)) |> st_make_valid()
#nearest_feature <- st_nearest_feature(oneloc, coast)
#clu <- read_sf('assets/CorporateLanduseInventory2010.shp')
#clu <- st_transform(clu, st_crs(pei_locs)) |> st_make_valid()

#locs_buff <- st_buffer(pei_locs, 150) |> select(location) |> distinct()
#clu_crop <- st_crop(clu, xmin=-63.8658,ymin=46.19434,xmax=-62.65111,ymax=46.6279)
#ints <- st_intersection(clu_crop, locs_buff)
#ints2 <- ints %>% 
  #mutate(area = st_area(.))

cover_cols = c("COVER1","COVER2","COVER3","COVER4","COVER5")
wetland_cols = c("CLASS1","CLASS2","CLASS3","CLASS4","CLASS5","CLASS6","CLASS7")

df_long <- ints2 %>%
  filter(!grepl('ASC|LXI|BS',location)) %>%
  select(location, COVER1, area) %>%
  distinct() %>%
  st_drop_geometry() %>%
  group_by(location, COVER1) %>%
  summarise(area = sum(area)) %>%
  ungroup() %>%
  pivot_wider(names_from = COVER1, values_from = area) %>%
  mutate_all(~replace(., is.na(.), 0)) %>%
  mutate(across(-location, ~as.numeric(.x))) %>%
  rowwise() %>%
  mutate(total = sum(c_across(-location))) %>%
  ungroup() %>%
  mutate(across(-c(location,total), ~ .x / total)) %>%
  select(-total)


lk_lc <- tibble(
  land_cover = c("GRS", "RM", "SOY", "TRE", "WS", "NA", "PAV", "WB", "AL", "SDW", "PO", "BAR", "BS", "BF"),
  description = c("Grass", "Red Maple", "SOY", "Trees", "White Spruce", "NA", "Paved", "White Birch",
                  "Alder", "Sand Dune", "Poplar", "Bare Soil", "Black Spruce", "Balsam Fir"))

df_lk <- df_long %>%
  pivot_longer(-location, names_to = "landcover", values_to = "landcover_proportion") %>%
  filter(!landcover_proportion == 0) %>%
  inner_join(., lk_lc, by = c("landcover" = "land_cover")) 

# Make up siteCovs for now
distance_to_coast <- read_csv("penp_coastline_distance.csv")
year_covs <- read_csv("year_covariates.csv")

covs <- distance_to_coast |>
  inner_join(df_lk) |>
  mutate(landcover = case_when(landcover %in% c("WS","BS","BF") ~ "Conifer",
                               landcover %in% c("RM","WB","AL","PO") ~ "Deciduous",
                               landcover %in% c("SOY","NA","PAV","TRE") ~ "Anthro",
                               landcover %in% c("SDW","BAR","GRS") ~ "Open",
                               TRUE ~ NA_character_)) |>
  group_by(location, coast_dist, landcover) |>
  summarise(landcover_proportion = sum((landcover_proportion))) |>
  ungroup()

locs_summary <- pei_locs |>
  st_drop_geometry() |>
  group_by(location, year) |>
  mutate(value = row_number()) |>
  ungroup() |>
  arrange(year) |>
  pivot_wider(names_from = year, values_from = value, values_fill = 0) |>
  mutate(Site = case_when(grepl('PENP-1-*',location) ~ "Cavendish",
                          grepl('PENP-2-*',location) ~ "Brackley",
                          grepl('PENP-3-*',location) ~ "Dalvay",
                          grepl('PENP-4-*',location) ~ "Greenwich",
                          grepl('PENP-5-*',location) ~ "Skmaqn",
                          grepl('PENP-BS-*',location) ~ "Bank Swallow Monitoring",
                          grepl('PENP-E1-*',location) ~ "Skmaqn",
                          TRUE ~ "Communities")) %>%
  rename('Location' = location)

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-cap: ARU monitoring locations surveyed each year as part of the songbird monitoring program.
#| label: fig-locs
#| cap-location: margin

ggplot() +
  geom_sf(data = pei_shp, fill = '#FFD580') +
  geom_sf(data = peinp_shp, fill = '#D0FFBC') +
  #geom_sf(data = coast, fill = "darkblue") +
  geom_point(data = pei_locs %>% inner_join(., locs_summary %>% select(Location, Site), by = c("location" = "Location")), 
             aes(x = st_coordinates(geometry)[,1], y = st_coordinates(geometry)[,2], colour = Site)) +
  scale_colour_viridis_d() +
  xlab("Longitude") +
  ylab("Latitude") +
  theme_void() +
  facet_wrap(~year, ncol=1) +
  theme(
    legend.position = "right",
    panel.background = element_rect(fill = "#A2C8EC")  # Change the background color here
  ) +
  xlim(-63.47902,-62.56987) +
  ylim(46.38308,46.51148)

```

```{r Location summary table}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| label: tbl-loc-summary
#| tbl-cap: Locations surveyed across years. Ones indicated a deployment in that year for that location

kable(locs_summary, caption = "Location summary for ARUs deployed")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| label: tbl-obvs-and-covs
#| tbl-cap: Site covariates for each forest songbird monitoring (PENP-*) location. Landcover is measured as proportion cover at 150 meter radius surrounding the ARU categorized into anthropogenic (pavement, soy), open (grass, sand dune, bare soil), deciduous (red maple, white birch, alder, poplar) and conifer (white spruce, black spruce, balsam fir).

covs_all <- covs %>%
  mutate_at(vars(landcover_proportion), ~round(., 2)) |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  rename("Distance from coast (m)" = coast_dist)


kable(covs_all, caption = "Location summary for ARUs deployed")

```

## Data management

A total of `r count_recs` recordings were collected (see @fig-recs-collect). From 2019 - 2021, data were transferred via hard drive to the University of Alberta in Edmonton, where they are redundantly stored on a server known as Cirrus. The recordings were standardized to ensure adherence to the naming convention of `LOCATION_DATETIME`, such as `PENP-1-1_20230625_053500.wav`. The remaining recordings (2022 - 2023) were directly uploaded to WildTrax by Parks Canada staff and can be downloaded from the platform's Recording tab, accessible under Manage \> Download list of recordings (see @fig-download-recs).

![Downloading a list of recordings from WildTrax](download-recs.png){#fig-download-recs}

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide

wildtrax_penp_recs <- read_csv("penp_recordings.csv") %>%
  select(location, recordingDate, `length(s)`) %>%
  rename("recording_date_time" = recordingDate) %>%
  rename("length_seconds" = `length(s)`) %>%
  mutate(recording_date_time = as.POSIXct(recording_date_time, format="%Y-%m-%d %H:%M"))

all_recs <- cirrus_penp_recs %>%
  select(location, recording_date_time, length_seconds) %>%
  bind_rows(., wildtrax_penp_recs) %>%
  select(location, recording_date_time, length_seconds) %>%
  distinct() %>%
  drop_na() %>%
  mutate(julian = yday(recording_date_time),
         hour = hour(recording_date_time),
         year = year(recording_date_time),
         month= month(recording_date_time, label = T))

count_recs <- nrow(all_recs)

average_deployment <- all_recs |>
  group_by(location, year) |>
  summarise(count = n_distinct(julian)) |>
  ungroup() |>
  summarise(mean = round(mean(count),2),
            sd = round(sd(count),2))

recs_plot <- all_recs |>
  rename("Location" = location) |>
  rename("Day of Year" = julian) |>
  ggplot(aes(x = `Day of Year`, y = Location, fill = Location)) +
  geom_density_ridges() +
  facet_wrap(~ year) +
  theme_minimal() +
  scale_fill_viridis_d()
  #scale_x_discrete(guide = guide_axis(check.overlap = TRUE))
  
```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-width: 10
#| fig-height: 10
#| fig-cap: Ridgeplot of recordings collected for each location over each survey year
#| label: fig-recs-collect
#| cap-location: margin

recs_plot

```

## Community data processing

The principal goal for data processing was to describe the acoustic community of species heard at locations while choosing a large enough subset of recordings for analyses. To ensure balanced replication, for each location and year surveyed, four randomly selected recordings were processed for 3-minutes between the hours of 4:00 AM - 7:59 AM ideally on four separate dates (see @tbl-loc-repl). Four recordings will ensure that we have the minimum number of samples for a simple occupancy analysis (@mackenzie2002estimating and @imperfect-occu). Tags are made using count-removal (see @farnsworth2002removal, @time-removal) where tags are only made at the time of first detection of each individual heard on the recordings. In case a species was overly abundant a TMTT ('too many to tag') flag was used (see @tbl-tmtt). `r round(nrow(tmtt_tags)/nrow(pei_main),2)*100`% of the total tags were TMTT but were subsequently converted to numeric using `wildRtrax::wt_replace_tmtt`. We also verified that all tags that were created were checked by a second observer (n = `r verified_tags |> select(Proportion) |> slice(3) |> pull()`) to ensure accuracy of detections (see @tbl-verified). Amphibian abundance was estimated at the time of first detection using the [North American Amphibian Monitoring Program](https://www.usgs.gov/centers/eesc/science/north-american-amphibian-monitoring-program) with abundance of species being estimated on the scale of "calling intensity index" (CI) of 1 - 3. Mammals such as Red Squirrel, were also noted on the recordings. After the data are processed in WildTrax, the [wildRtrax](https://abbiodiversity.github.io/wildRtrax/) package is use to download the data into a standard format prepared for analysis. The `wt_download_report` function downloads the data directly to a R framework for easy manipulation (see [wildRtrax APIs](https://abbiodiversity.github.io/wildRtrax/articles/apis.html)).

```{r Data download}
#| warning: false
#| message: false
#| echo: true
#| eval: false
#| include: true

pei_projects <- wildRtrax::wt_get_download_summary(sensor = 'ARU') |>
  filter(grepl('^Prince Edward Island National Park Forest Songbird', project)) |>
  select(project_id) |>
  pull()

pei_main <-
  map_dfr(
    .x = pei_projects,
    .f = ~ wildRtrax::wt_download_report(
      project_id = .x,
      sensor_id = "ARU",
      weather_cols = T,
      reports = "main"
    )
  )
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| eval: true
#| include: false

pei_main |> names()

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true

pei_tasks <- pei_main |>
  as_tibble() |>
  filter(aru_task_status %in% c("Transcribed","New")) |>
  select(project_id, location, recording_date_time, task_duration, task_method, observer_id) |>
  distinct() |>
  mutate(hour = lubridate::hour(recording_date_time),
         year = lubridate::year(recording_date_time),
         typ = case_when(
    hour >= 4 & hour <= 7 ~ "Dawn",
    hour > 7 & hour < 20 ~ "Day",
    hour >= 19 & hour < 21 ~ "Dusk",
    TRUE ~ "Night"
  )) |>
  group_by(location, year, task_duration, typ) |>
  tally() |>
  ungroup() |>
  filter(location == "PENP-1-1")


task_info <- fs::dir_ls('tasks', regexp = "*.csv") |>
  map_dfr(~read_csv(., show_col_types = F)) |>
  select(internal_task_id, rain:audioQuality) |>
  distinct()

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| label: tbl-loc-repl
#| tbl-cap: Example of tasks and unit replication for listening at PENP-1-1

kable(pei_tasks)
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: tbl-verified
#| tbl-cap: Proportion of tags verified

all_tags <- pei_main |> 
  tally() |>
  pull()

verified_tags <- pei_main |>
  group_by(tag_is_verified) |>
  tally() |>
  mutate(Proportion = round(n / all_tags,4)*100) |>
  rename("Count" = n) |>
  rename("Tag is verified" = tag_is_verified)

kable(verified_tags)
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: tbl-tmtt
#| tbl-cap: TMTT tags

tmtt_tags <- pei_main |>
  select(location, recording_date_time, species_code, individual_count) |>
  distinct() |>
  filter(individual_count == "TMTT")

kable(head(tmtt_tags))

```

## Visual scanning

Visual scanning is the concept of visually examining spectrograms in order to find a signal within an audio recording. Visual scanning can be a useful processing method allowing trained users to process recordings much faster than traditional listening. It has been used for detecting different taxa (amphibians: @vis-scan-amphs, mammals: @aru-vs-cams-wolves) with comparable biological metrics, as well as helping to maximize species detection in large acoustic monitoring data sets (@all-the-scans). WildTrax's project settings and dynamic spectrogram settings in the processing interface allow users to upload many recordings, while also allowing frequency-limited or time-limited spectrograms. These changes are easily made by adjusting project settings in WildTrax (see @fig-project-dynamic).

![Dynamic spectrogram and project settings in WildTrax](project-dynamic.png){#fig-project-dynamic}

```{r}
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| include: false

just_bans <- wildRtrax::wt_get_download_summary(sensor = 'ARU') |>
  filter(grepl('National Park Bank Swallow', project)) |>
  select(project_id) |>
  pull()

just_bans_main <-
  map_dfr(
    .x = just_bans,
    .f = ~ wildRtrax::wt_download_report(
      project_id = .x,
      sensor_id = "ARU",
      weather_cols = T,
      reports = "main"
    )
  )

jbm <- just_bans_main |>
  mutate(individual_count = as.character(individual_count)) |>
  bind_rows(pei_main) |>
  filter(species_code == "BANS") |>
  select(location, recording_date_time, species_code, individual_order, individual_count) |>
  distinct()

```

In order to determine presence of Bank Swallow (BANS) at `PENP-BS-*` site, visual scanning was employed to identify the time of first detection of the species on recordings at these locations. A total of `r pei_main |> filter(grepl('BS',location)) |> select(location, recording_date_time, task_method) |> distinct() |> tally() |> pull() + nrow(just_bans_main)` recordings were visually scanned for BANS. Tags were made at the time of first detection in each minute interval.

## Automated recognition

Automated recognition is a well-known process to help detect rare and elusive species (@knight2019classification. @shonfield2018utility) as well as species that may have a low detectability by collecting large data sets. In order to determine the presence of a few key species-at-risk, we utilized automated recognizers and deployed them across all the recordings in the 2019 data set. We constructed a recognizer for Eastern Wood-Pewee (EAWP) and used three previously constructed Wildlife Acoustics SongScope recognizers for Olive-sided Flycatcher (OSFL), Rusty Blackbird (RUBL) and Canada Warbler (CAWA) to detect for the presence of these species in the 2019 data set. All recognizers are freely available on WildTrax under Methods and Protocols \> [Automated Recognizers](https://wildtrax.ca/resources/methods-protocols/automated-recognizers/). Hits were verified and true positives for presence at each location (recording where the species was first positively detected) were uploaded to WildTrax via the `wt_songscope_tags` function in `wildRtrax`.

## Analyses

Species richness, diversity and occupancy were calculated using the `r nrow(locs_summary) - 9` forest songbird monitoring locations (`PENP-`). We calculated species richness as distinct species found at each location and year surveyed (see @fig-spp-rich-locs), omitting species using `wildRtrax::wt_tidy_species()` for abiotic, amphibians, unknowns and insects. To determine if there were any changes to species diversity, we used Shannon's diversity index over years using `vegan::diversity` (see @fig-shannon).

For testing species occupancy, we selected locations with a minimum of four dawn visits for each year across all five years, focusing on forest obligate species for ecological relevance (see @tbl-bird-guilds). Utilizing a single-season single-species occupancy model from @mackenzie2002estimating, we calculated the predicted occupancy of species at all locations surveyed in each year across years. Site-specific covariates included the distance to ocean edge (in meters) and the proportional area of each cover type from the [Prince Edward Island 2010 Corporate Land Use Inventory](https://data.princeedwardisland.ca/Environment-and-Food/OD0144-Corporate-Landuse-Inventory-2010/tc7z-7rpy) at 150 meter radius surrounding the ARU categorized into anthropogenic (pavement, soy), open (grass, sand dune, bare soil), deciduous (red maple, white birch, alder, poplar) and conifer (white spruce, black spruce, balsam fir). Observation covariates incorporated day of the year, hour, observer, and a quadratic term for both day of year ($doy^{2}$) and hour ($hr^{2}$). See @tbl-obvs-and-covs for more information. Despite variations in processing methodology between 2019 - 2020 (1SPM - species-individual detected per minute, i.e. repeat sampling each minute for 3 minute) and subsequent years (2021 - 2023; 1SPT), we maintained consistency by exclusively utilizing the time to the first detection of individuals from the 1SPM recordings. Model predictions were generated, with goodness-of-fit testing using methods from @occu-fit and the best model selected based on AIC and through `MuMIn::dregde`, `MuMIn::get.models` and `MuMIn::model.sel`. If more than one model existed, the average model was used using `MuMIn::model.avg`. The final predictions were then made and plotted over years and sorted by nesting guilds of species into conifer, deciduous, treed / shrubby and open.

------------------------------------------------------------------------

# Results

## Species richness

A total of `r nrow(distinct_spp)` species were found across the five years. @fig-spp-rich-locs describes the relationship of species richness across each location and survey year with @fig-spp-rich-annual showing the relationship between species richness and survey effort.

```{r}
#| warning: false
#| message: false
#| echo: false
#| eval: true
#| include: false

spp_rich_location <- pei_main |>
  as_tibble() |>
  filter(!grepl('BS|ASC|LXI',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  mutate(year = lubridate::year(recording_date_time)) |>
  filter(!(location == 'PENP-BS-6' & task_method != "1SPT")) |>
  select(location, year, species_code) |>
  distinct() |>
  group_by(location, year) |>
  summarise(species_count = n_distinct(species_code)) |>
  ungroup()

distinct_spp <- pei_main |>
  as_tibble() |>
  filter(!grepl('BS|ASC|LXI',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  mutate(year = lubridate::year(recording_date_time)) |>
  filter(!(location == 'PENP-BS-6' & task_method != "1SPT")) |>
  select(species_code) |>
  distinct() |>
  arrange(species_code)
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| eval: true
#| include: true
#| fig-align: center
#| fig-width: 10
#| fig-height: 10
#| fig-cap: Species richness at forest monitoring locations across years
#| label: fig-spp-rich-locs
#| cap-location: margin

spp_rich_location |>
  ggplot(aes(x=year, y=species_count, colour=year)) +
  geom_line() +
  geom_point() +
  facet_wrap(~location) +
  theme_bw() +
  scale_colour_viridis_c() +
  xlab('Year') + ylab('Species richness') +
  ggtitle('Species richness at each location surveyed for each year')

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| results: hide

spp_rich_annual <- pei_main |>
  as_tibble() |>
  filter(!grepl('BS|ASC|LXI',location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  mutate(year = lubridate::year(recording_date_time)) |>
  filter(!(location == 'PENP-BS-6' & task_method != "1SPT")) |>
  select(location, year, species_code) |>
  distinct() |>
  group_by(year) |>
  summarise(effort = n_distinct(species_code) / n_distinct(location),
            species_count = n_distinct(species_code)) |>
  ungroup()

year_effort <- pei_main |>
  mutate(year = lubridate::year(recording_date_time)) |>
  group_by(year) |>
  summarise(count_of_locs = n_distinct(location))
```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| fig-align: center
#| fig-width: 10
#| fig-height: 10
#| fig-cap: Species richness at forest monitoring locations across years considering sampling effort
#| label: fig-spp-rich-annual
#| cap-location: margin

spp_rich_annual_plot <- spp_rich_annual %>%
  inner_join(., year_effort) %>%
  ggplot(., aes(x = year)) +
  geom_line(aes(y = species_count), size = 1) +
  geom_bar(aes(y = count_of_locs * 5), alpha = 0.7, stat = "identity") +  # Adjust the multiplier for better visualization
  scale_y_continuous(name = "Species Count", sec.axis = sec_axis(~./5, name = "Count of Locations")) +
  labs(x = "Year") +
  theme_bw()

spp_rich_annual_plot

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| label: tbl-bird-guilds
#| tbl-cap: Common bird forest species guilds. For nesting habitat; Ag = Agricultural, Be = Beach, Bo = Bog, CW = Coniferous Woodlands, ES = Early Successional, MW = Mixed Woodlands, OW = Open Woodlands, TSS = Treed/Shrubby Swamp, Ur = Urban. Species from CW, MW, OW, TSS were used for analysis.

guilds <- read_csv("bird_guilds.csv") |>
  select(species_common_name, habitat_nesting) |>
  filter(habitat_nesting %in% c("CW","MW","OW","TSS")) 

kable(guilds)

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-width: 10
#| fig-height: 10
#| fig-cap: Seasonal detection activity of most commonly detected forest species
#| label: fig-spp-activity
#| cap-location: margin

pei_main |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  filter(!grepl('BS|ASC|LXI',location)) |>
  select(location, recording_date_time, species_common_name, species_code, individual_count) |>
  mutate(julian = lubridate::yday(recording_date_time),
         month= month(recording_date_time),
         year = factor(year(recording_date_time))) |>
  inner_join(guilds |> select(species_common_name, habitat_nesting)) |>
  arrange(species_code) |>
  filter(habitat_nesting %in% c("CW","MW","OW","TSS")) |>
  group_by(species_code) |>
  add_tally() |>
  ungroup() |>
  filter(!n < 100) |>
  mutate(habitat_nesting = case_when(
    habitat_nesting == "CW" ~ "Coniferous Woodland",
    habitat_nesting == "MW" ~ "Mixedwood",
    habitat_nesting == "OW" ~ "Open Woodland",
    habitat_nesting == "TSS" ~ "Tree Shrub / Swamp",
    TRUE ~ as.character(habitat_nesting)
  )) |>
  rename("Nesting habitat" = habitat_nesting) |>
  ggplot(aes(x = julian, y = species_common_name, fill = `Nesting habitat`)) + 
  geom_density_ridges(scale = 3, rel_min_height = 0.005, alpha = 0.4) + 
  scale_fill_viridis_d() +
  facet_wrap(~year, nrow = 1) +
  xlim(120,210) +
  theme_bw() +
  xlab("Day of Year") + 
  ylab("Species")

```

```{r}
#| warning: false
#| echo: false
#| eval: false
#| include: true

library(lmtest)

ocean_richness <- spp_rich_location |>
  inner_join(distance_to_coast) |>
  filter(!location %in% c('ASC-1'))

ggplot(ocean_richness, aes(x = coast_dist, y = species_count)) +
  geom_point() +
  labs(title = "Scatter plot of species_count vs coast_dist",
       x = "coast_dist",
       y = "species_count")

# Fit a linear regression model
model <- glm(species_count ~ coast_dist, data = ocean_richness)
test_independence <- dwtest(model)$p.value # Independence
test_resid_normality <- shapiro.test(resid(model))$p.value # Normality of residuals
test_homoscedasticity <- car::ncvTest(model)$p # Homoscedasticity



# Check the summary of the model
summary(model)

# Interpret the results
# Look at the p-value for the 'coast_dist' coefficient
# If the p-value is less than your chosen significance level (e.g., 0.05), you can reject the null hypothesis that the coefficient is zero.

# Additional diagnostics and visualization
# Check residuals vs. fitted values, normal Q-Q plot, etc.
plot(model)

# You can also check for multicollinearity if there are other predictors

# Consider transforming variables or using different models if assumptions are violated

# Make predictions
predictions <- predict(model, newdata = ocean_richness)

# Visualize the predicted values against the actual values
ggplot(ocean_richness, aes(x = coast_dist, y = species_count)) +
  geom_point() +
  geom_line(aes(y = predictions), color = "red") +
  labs(title = "Predicted vs. Actual values",
       x = "coast_dist",
       y = "species_count")

BC_model <- caret::BoxCoxTrans(ocean_richness$species_count)
ocean_richness <- cbind(ocean_richness, dist_new=predict(BC_model, ocean_richness$species_count)) # append the transformed variable to cars

lm(dist_new ~ coast_dist, data = ocean_richness)
```

## Species diversity

Shannon's diversity was stable based on results. (see @fig-shannon.)

```{r}
#| warning: false
#| eval: false
#| message: false
#| include: false
#| echo: false
#| results: hide

raw_dog <- pei_main |> 
  as_tibble() |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  filter(!grepl('BS|ASC|LXI',location)) |>
  wt_replace_tmtt() |>
  select(location, recording_date_time, species_code, species_common_name, individual_order, individual_count) |>
  distinct() |>
  group_by(location, recording_date_time, species_code, species_common_name) |>
  summarise(count = max(individual_order)) |>
  ungroup() |>
  pivot_wider(names_from = species_code, values_from = count, values_fill = 0) |>
  as.data.frame()

shannon <- raw_dog |>
  pivot_longer(cols = -(location:species_common_name), names_to = "species", values_to = "count") %>%
  group_by(location, year = lubridate::year(recording_date_time), species) %>%
  summarise(total_count = sum(count)) %>%
  ungroup() %>%
  filter(!total_count == 0) %>%
  group_by(year) %>%
  summarise(shannon_index = diversity(total_count, index = "shannon")) |>
  ungroup() |>
  ggplot(aes(x = year, y = shannon_index, color = year)) +
  geom_line() +
  geom_point() +
  labs(title = "Shannon Diversity Index Over Years",
       x = "Year",
       y = "Shannon Diversity Index") +
  theme_minimal() +
  scale_colour_viridis_c() +
  ylim(4,6)

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| fig-width: 8
#| fig-height: 8
#| fig-cap: Shannon's diversity across years for all locations surveyed.
#| label: fig-shannon
#| fig-column: page-right

shannon

```

## Species occupancy

We selected `20` species to represent the forest songbird community into 4 separate habitat nesting guilds (see @tbl-bird-guilds): conifer (@fig-spp-occ-conifer), deciduous (@fig-spp-occ-decid), treed / shrubby (@fig-spp-occ-tss) and open (@fig-spp-occ-open). Analysis of species occupancy revealed diverse and varied changes across these species. Analytically, many models were singular, and a few exhibited overdispersion (indicated by *c-hat* in @tbl-c-hat), likely due to low detections or a limited sample size of spatial locations. Ubiquitous species such as Yed-eyed Vireo, Yellow-rumped Warbler, Magnolia Warbler and Northern Parula, demonstrated stable site occupancy across the years. Generalist species or those capable of capitalizing on utilizing mixed habitats, exemplified by the Northern Parula, also maintained consistent occupancy levels. The occurrence of Hurricane Fiona in 2023 led to notable breakpoints in the occupancy of certain species: coniferous species, including the Black-throated Green Warbler, Black-throated Blue Warbler, Blackburnian Warbler, Golden-crowned Kinglet, and Mourning Warbler, experienced declines. Conversely, increases were observed in guilds of species that favor more open or shrubby habitats, such as the Alder Flycatcher and American Redstart. Thrushes (American Robin, Swainson's Thrush, Hermit Thrush) had notably wavering occupancy throughout the years.

```{r}
#| warning: false
#| echo: false
#| eval: false
#| include: true

#wtsp_occ <- ss_occ_plot_loop(pei_main, "WTSP")
#amro_occ <- ss_occ_plot_loop(pei_main, "AMRO")
revi_occ <- ss_occ_plot_loop(pei_main, "REVI")
#coye_occ <- ss_occ_plot_loop(pei_main, "COYE")
amre_occ <- ss_occ_plot_loop(pei_main, "AMRE")
btnw_occ <- ss_occ_plot_loop(pei_main, "BTNW")
nopa_occ <- ss_occ_plot_loop(pei_main, "NOPA")
#yewa_occ <- ss_occ_plot_loop(pei_main, "YEWA")
mawa_occ <- ss_occ_plot_loop(pei_main, "MAWA")
#sosp_occ <- ss_occ_plot_loop(pei_main, "SOSP")
swth_occ <- ss_occ_plot_loop(pei_main, "SWTH")
alfl_occ <- ss_occ_plot_loop(pei_main, "ALFL")
yrwa_occ <- ss_occ_plot_loop(pei_main, "YRWA")
#baww_occ <- ss_occ_plot_loop(pei_main, "BAWW")
bhvi_occ <- ss_occ_plot_loop(pei_main, "BHVI")
blja_occ <- ss_occ_plot_loop(pei_main, "BLJA")
#chsp_occ <- ss_occ_plot_loop(pei_main, "CHSP")
btbw_occ <- ss_occ_plot_loop(pei_main, "BTBW")
blbw_occ <- ss_occ_plot_loop(pei_main, "BLBW")
gcki_occ <- ss_occ_plot_loop(pei_main, "GCKI")
#wiwr_occ <- ss_occ_plot_loop(pei_main, "WIWR")
#rbnu_occ <- ss_occ_plot_loop(pei_main, "RBNU")
#brcr_occ <- ss_occ_plot_loop(pei_main, "BRCR")
mowa_occ <- ss_occ_plot_loop(pei_main, "MOWA")
heth_occ <- ss_occ_plot_loop(pei_main, "HETH")
#oven_occ <- ss_occ_plot_loop(pei_main, "OVEN")
eawp_occ <- ss_occ_plot_loop(pei_main, "EAWP")
#cawa_occ <- ss_occ_plot_loop(pei_main, "CAWA")

```

```{r}
#| warning: false
#| echo: false
#| eval: false
#| include: true

ss_occ_plot_loop <- function(input, species_choice) {
  
  data <- input
  
  pei_occu_all <- pei_main |>
    as_tibble() |>
    filter(aru_task_status == "Transcribed") |>
    filter(!grepl('BS|ASC|LXI|E1',location)) |>
    wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown")) |>
    left_join(guilds |> select(species_common_name, habitat_nesting)) |>
    filter(habitat_nesting %in% c("CW","MW","OW","TSS")) |>
    wt_replace_tmtt() |>
    mutate(task_duration = gsub('s','',task_duration) %>% as.numeric()) |>
    filter(!task_duration > 180, !(grepl('PENP-BS-*',location) & task_method != '1SPT')) |>
    mutate(hour = lubridate::hour(recording_date_time),
            year = lubridate::year(recording_date_time)) |>
  # group_by(location) |>
  # mutate(ct = n_distinct(year)) |>
  # ungroup() |>
  # filter(ct == 5) |>
  filter(hour %in% c(4:7)) |>
  group_split(year)
  
  pei_occu_19 <- pei_occu_all[[1]]
  pei_occu_20 <- pei_occu_all[[2]]
  pei_occu_21 <- pei_occu_all[[3]]
  pei_occu_22 <- pei_occu_all[[4]]
  pei_occu_23 <- pei_occu_all[[5]]
  

site_covariates_19 <- pei_occu_19 |>
  inner_join(covs) |>
  select(location, year, coast_dist, landcover, landcover_proportion) |>
  distinct() |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  group_by(location, year, coast_dist) |>
  summarise(across(starts_with(c("Anthro","Deciduous","Open","Conifer")), max)) |>
  ungroup()
  # pivot_longer(-c(location:coast_dist), names_to = "landcover", values_to = "landcover_proportion") |>
  # group_by(location, year, coast_dist) |>
  # filter(landcover_proportion == max(landcover_proportion)) |>
  # ungroup()

# Print the result

site_covariates_20 <- pei_occu_20 |>
  inner_join(covs) |>
  select(location, year, coast_dist, landcover, landcover_proportion) |>
  distinct() |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  group_by(location, year, coast_dist) |>
  summarise(across(starts_with(c("Anthro","Deciduous","Open","Conifer")), max)) |>
  ungroup()
  # pivot_longer(-c(location:coast_dist), names_to = "landcover", values_to = "landcover_proportion") |>
  # group_by(location, year, coast_dist) |>
  # filter(landcover_proportion == max(landcover_proportion)) |>
  # ungroup()

site_covariates_21 <- pei_occu_21 |>
  inner_join(covs) |>
  select(location, year, coast_dist, landcover, landcover_proportion) |>
  distinct() |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  group_by(location, year, coast_dist) |>
  summarise(across(starts_with(c("Anthro","Deciduous","Open","Conifer")), max)) |>
  ungroup()
  # pivot_longer(-c(location:coast_dist), names_to = "landcover", values_to = "landcover_proportion") |>
  # group_by(location, year, coast_dist) |>
  # filter(landcover_proportion == max(landcover_proportion)) |>
  # ungroup()

site_covariates_22 <- pei_occu_22 |>
  inner_join(covs) |>
  select(location, year, coast_dist, landcover, landcover_proportion) |>
  distinct() |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  group_by(location, year, coast_dist) |>
summarise(across(starts_with(c("Anthro","Deciduous","Open","Conifer")), max)) |>
  ungroup()
  # pivot_longer(-c(location:coast_dist), names_to = "landcover", values_to = "landcover_proportion") |>
  # group_by(location, year, coast_dist) |>
  # filter(landcover_proportion == max(landcover_proportion)) |>
  # ungroup()

site_covariates_23 <- pei_occu_23 |>
  inner_join(covs) |>
  select(location, year, coast_dist, landcover, landcover_proportion) |>
  distinct() |>
  pivot_wider(names_from = landcover, values_from = landcover_proportion, values_fill = 0) |>
  group_by(location, year, coast_dist) |>
  summarise(across(starts_with(c("Anthro","Deciduous","Open","Conifer")), max)) |>
  ungroup()
  # pivot_longer(-c(location:coast_dist), names_to = "landcover", values_to = "landcover_proportion") |>
  # group_by(location, year, coast_dist) |>
  # filter(landcover_proportion == max(landcover_proportion)) |>
  # ungroup()

print('Breaking here?')

occu_one_19 <- wt_format_occupancy(pei_occu_19, siteCovs = site_covariates_19, species = species_choice)
occu_one_20 <- wt_format_occupancy(pei_occu_20, siteCovs = site_covariates_20, species = species_choice)
occu_one_21 <- wt_format_occupancy(pei_occu_21, siteCovs = site_covariates_21, species = species_choice)
occu_one_22 <- wt_format_occupancy(pei_occu_22, siteCovs = site_covariates_22, species = species_choice)
occu_one_23 <- wt_format_occupancy(pei_occu_23, siteCovs = site_covariates_23, species = species_choice)

print('Breaking here2?')

sitecovs_to_scale <- c("coast_dist","Anthro","Open","Conifer","Deciduous")

for (variable in sitecovs_to_scale) {
  occu_one_19@siteCovs[[variable]] <- scale(occu_one_19@siteCovs[[variable]])
  occu_one_20@siteCovs[[variable]] <- scale(occu_one_20@siteCovs[[variable]])
  occu_one_21@siteCovs[[variable]] <- scale(occu_one_21@siteCovs[[variable]])
  occu_one_22@siteCovs[[variable]] <- scale(occu_one_22@siteCovs[[variable]])
  occu_one_23@siteCovs[[variable]] <- scale(occu_one_23@siteCovs[[variable]])
}

obscovs_to_scale <- c("doy","hr","doy2","hr2")

for (variable in obscovs_to_scale) {
  occu_one_19@obsCovs[[variable]] <- scale(occu_one_19@obsCovs[[variable]])
  occu_one_20@obsCovs[[variable]] <- scale(occu_one_20@obsCovs[[variable]])
  occu_one_21@obsCovs[[variable]] <- scale(occu_one_21@obsCovs[[variable]])
  occu_one_22@obsCovs[[variable]] <- scale(occu_one_22@obsCovs[[variable]])
  occu_one_23@obsCovs[[variable]] <- scale(occu_one_23@obsCovs[[variable]])
}

print('Breaking here4?')

occu_model_19 <- occu(~ doy2 + hr2 ~ Anthro + Open + Deciduous + Conifer, occu_one_19)
occu_model_20 <- occu(~ doy2 + hr2 ~ Anthro + Open + Deciduous + Conifer, occu_one_20)
occu_model_21 <- occu(~ doy2 + hr2 ~ Anthro + Open + Deciduous + Conifer, occu_one_21)
occu_model_22 <- occu(~ doy2 + hr2 ~ Anthro + Open + Deciduous + Conifer, occu_one_22)
occu_model_23 <- occu(~ doy2 + hr2 ~ Anthro + Open + Deciduous + Conifer, occu_one_23)

print('Breaking here5?')

# gof19 <- mb.gof.test(occu_model_19, nsim=1000, plot.hist=F)
# gof20 <- mb.gof.test(occu_model_20, nsim=1000, plot.hist=F)
# gof21 <- mb.gof.test(occu_model_21, nsim=1000, plot.hist=F)
# gof22 <- mb.gof.test(occu_model_22, nsim=1000, plot.hist=F)
# gof23 <- mb.gof.test(occu_model_23, nsim=1000, plot.hist=F)

print('Breaking her65?')

# print(gof19$c.hat.est)
# print(gof20$c.hat.est)
# print(gof21$c.hat.est)
# print(gof22$c.hat.est)
# print(gof23$c.hat.est)

print('Breaking heasadsasdr65?')

occ_dredge_19 <- dredge(occu_model_19)
occ_dredge_delta_19 <- get.models(occ_dredge_19, subset = delta <= 2.5)
if(length(occ_dredge_delta_19) == 1){occ_avg_19 <- NULL} else {occ_avg_19 <- model.avg(occ_dredge_delta_19, fit = TRUE)}
if (is.null(occ_avg_19)) {occ_fit_19 <- predict(occu_model_19, site_covariates_19, type="state",interval="confidence")}  else {occ_fit_19 <- predict(occ_avg_19, site_covariates_19, type="state",interval="confidence")}
if ("fit" %in% colnames(occ_fit_19 %>% as_tibble())) {occ_graph_19 <- occ_fit_19 %>% as_tibble() %>% bind_cols(., site_covariates_19)} else {occ_graph_19 <- occ_fit_19 %>% as_tibble() %>% bind_cols(., site_covariates_19) %>% rename("fit" = Predicted)}

print('Breaking her65???S??')

occ_dredge_20 <- dredge(occu_model_20)
occ_dredge_delta_20 <- get.models(occ_dredge_20, subset = delta <= 2.5)
if(length(occ_dredge_delta_20) == 1){occ_avg_20 <- NULL} else {occ_avg_20 <- model.avg(occ_dredge_delta_20, fit = TRUE)}
if (is.null(occ_avg_20)) {occ_fit_20 <- predict(occu_model_20, site_covariates_20, type="state",interval="confidence")} else {occ_fit_20 <- predict(occ_avg_20, site_covariates_20, type="state",interval="confidence")}
if ("fit" %in% colnames(occ_fit_20 %>% as_tibble())) {occ_graph_20 <- occ_fit_20 %>% as_tibble() %>% bind_cols(., site_covariates_20)} else {occ_graph_20 <- occ_fit_20 %>% as_tibble() %>% bind_cols(., site_covariates_20) %>% rename("fit" = Predicted)}

print('Breaking her65kjdslkhsdj?')

occ_dredge_21 <- dredge(occu_model_21)
occ_dredge_delta_21 <- get.models(occ_dredge_21, subset = delta <= 2.5)
if(length(occ_dredge_delta_21) == 1){occ_avg_21 <- NULL} else {occ_avg_21 <- model.avg(occ_dredge_delta_21, fit = TRUE)}
if (is.null(occ_avg_21)) {occ_fit_21 <- predict(occu_model_21, site_covariates_21, type="state",interval="confidence")} else {occ_fit_21 <- predict(occ_avg_21, site_covariates_21, type="state",interval="confidence")}
if ("fit" %in% colnames(occ_fit_21 %>% as_tibble())) {occ_graph_21 <- occ_fit_21 %>% as_tibble() %>% bind_cols(., site_covariates_21)} else {occ_graph_21 <- occ_fit_21 %>% as_tibble() %>% bind_cols(., site_covariates_21) %>% rename("fit" = Predicted)}

print('Breaking her65kjdssdsaflkhsdj?')

occ_dredge_22 <- dredge(occu_model_22)
occ_dredge_delta_22 <- get.models(occ_dredge_22, subset = delta <= 2.5)
if(length(occ_dredge_delta_22) == 1){occ_avg_22 <- NULL} else {occ_avg_22 <- model.avg(occ_dredge_delta_22, fit = TRUE)}
if (is.null(occ_avg_22)) {occ_fit_22 <- predict(occu_model_22, site_covariates_22, type="state",interval="confidence")} else {occ_fit_22 <- predict(occ_avg_22, site_covariates_22, type="state",interval="confidence")}
if ("fit" %in% colnames(occ_fit_22 %>% as_tibble())) {occ_graph_22 <- occ_fit_22 %>% as_tibble() %>% bind_cols(., site_covariates_22)} else {occ_graph_22 <- occ_fit_22 %>% as_tibble() %>% bind_cols(., site_covariates_22) %>% rename("fit" = Predicted)}

print('Breaking aaaaa?')

occ_dredge_23 <- dredge(occu_model_23)
occ_dredge_delta_23 <- get.models(occ_dredge_23, subset = delta <= 2.5)
if(length(occ_dredge_delta_23) == 1){occ_avg_23 <- NULL} else {occ_avg_23 <- model.avg(occ_dredge_delta_23, fit = TRUE)}
if (is.null(occ_avg_23)) {occ_fit_23 <- predict(occu_model_23, site_covariates_23, type="state",interval="confidence")} else {occ_fit_23 <- predict(occ_avg_23, site_covariates_23, type="state",interval="confidence")}
if ("fit" %in% colnames(occ_fit_23 %>% as_tibble())) {occ_graph_23 <- occ_fit_23 %>% as_tibble() %>% bind_cols(., site_covariates_23)} else {occ_graph_23 <- occ_fit_23 %>% as_tibble() %>% bind_cols(., site_covariates_23) %>% rename("fit" = Predicted)}

print('Breaking her58?')

occ_graph_all <- bind_rows(occ_graph_19, occ_graph_20, occ_graph_21, occ_graph_22, occ_graph_23)

zz <- data |>
  select(species_code, species_common_name) |>
  distinct() |>
  filter(species_code == species_choice) |>
  select(species_common_name) |>
  pull()
  
occ_plot <- ggplot(occ_graph_all %>%
         mutate(year = factor(year)) %>%
  select(fit:year), aes(x = year, y = fit, fill=year)) +
  geom_boxplot() +
  ylim(0.00,1.00) +
  labs(title = paste0(zz),
       x = "Year") +
  theme_bw() +
  theme(legend.position="none") +
  scale_fill_viridis_d()
  
  return(occ_plot)
  
}

# Where input in the cleaned data and species_choice is the list of forest obligate species.


```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| fig-width: 12
#| fig-height: 12
#| fig-cap: Predicted single-season occupancy of forest species (Habitat nesting = Conifer) within Prince Edward Island National Park. The data represents the average species occupancy across all surveyed locations for each respective year.
#| label: fig-spp-occ-conifer
#| fig-column: page-right

#occ_spp |> select(species_code) |> slice(1:20) |> pull()

ggarrange(btnw_occ, blbw_occ, gcki_occ, yrwa_occ, mawa_occ, btbw_occ, bhvi_occ)

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| fig-width: 12
#| fig-height: 12
#| fig-cap: Predicted single-season occupancy of forest species (Habitat nesting = Deciduous) within Prince Edward Island National Park. The data represents the average species occupancy across all surveyed locations for each respective year.
#| label: fig-spp-occ-decid
#| fig-column: page-right

#occ_spp |> select(species_code) |> slice(1:20) |> pull()

ggarrange(amre_occ, revi_occ, mowa_occ, blja_occ)

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| fig-width: 12
#| fig-height: 12
#| fig-cap: Predicted single-season occupancy of forest species (Habitat nesting = Treed / Shrubby) within Prince Edward Island National Park. The data represents the average species occupancy across all surveyed locations for each respective year.
#| label: fig-spp-occ-tss
#| fig-column: page-right

#occ_spp |> select(species_code) |> slice(1:20) |> pull()

ggarrange(alfl_occ)

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| fig-width: 12
#| fig-height: 12
#| fig-cap: Predicted single-season occupancy of forest species (Habitat nesting = Open) within Prince Edward Island National Park. The data represents the average species occupancy across all surveyed locations for each respective year.
#| label: fig-spp-occ-open
#| fig-column: page-right

#occ_spp |> select(species_code) |> slice(1:20) |> pull()

ggarrange(eawp_occ)

```

```{r}
#| warning: false
#| echo: false
#| eval: false
#| include: false
#| results: hide
#| message: false

coast_model <- glm(COYE ~ recording_date_time + coast_dist, offset=offstz$COYE.off, data=pei_wide_plus)

pei_wide <- pei_main %>%
  wt_tidy_species(., remove = c("mammal","amphibian","abiotic","insect","unknown")) %>%
  wt_replace_tmtt() %>%
  wt_make_wide(sound = "all")
  
offstz <- pei_wide %>%
  wt_qpad_offsets(species = "all", version = 3, together = F)

pei_wide_plus <- pei_wide %>%
  mutate(recording_date_time = yday(recording_date_time)) %>%
  inner_join(., distance_to_coast)

my_qpad_model <- glm(OVEN ~ recording_date_time, offset=offstz$OVEN.off, data=pei_wide_plus)

# Create a data frame for predictions
predictions <- data.frame(
  recording_date_time = seq(min(pei_wide_plus$recording_date_time), 
                            max(pei_wide_plus$recording_date_time), length.out = 464))

# Make predictions using the model
predictions$predicted_abundance <- predict(my_qpad_model, data = predictions, type = "response")

# Create the ggplot
ggplot(pei_wide_plus, aes(x = recording_date_time, y = COYE)) +
  geom_point(alpha = 0.5) +  # Scatter plot of actual data
  geom_line(data = predictions, aes(x = recording_date_time, y = predicted_abundance), color = "blue", size = 1) +
  labs(title = "Abundance vs. Recording Date Time",
       x = "Recording Date Time",
       y = "Abundance") +
  theme_minimal()

```

## Visual scanning

BANS were detected at `r jbm |> select(location) |> tally()` distinct locations (`r jbm |> select(location) |> distinct() |> pull()`).

## Automated recognition

We found that there was no advantage to utilizing the recognizer to find Eastern Wood-Pewee over human transcribing as the species was very detectable (see @tbl-recog-results).

------------------------------------------------------------------------

## Amphibians

A total of `r amphs_only |> select(species_code) |> distinct() |> tally()` were detected: `r amphs_only |> select(species_code) |> distinct() |> pull()`. A preliminary pattern of amphibian activity can be seen in @fig-spp-amphs-day for Green Frog and Spring Peeper where there were enough detections to generate activity patterns. Spring peeper activity commenced much earlier than Green Frog although seasonal patterns are consistent with the species' phenology (see @lovett2013peepers, @ackleh2010measuring).

```{r}
#| warning: false
#| echo: false
#| eval: true
#| include: true
#| results: hide
#| fig-width: 7
#| fig-height: 7
#| fig-cap: Seasonal and yearly activity plots for Green Frog and Spring Peeper
#| label: fig-spp-amphs-day
#| fig-column: page-right


spp_table <- wt_get_species()

amphs <- spp_table %>%
  filter(species_class == "AMPHIBIA")

amphs_only <- pei_main %>%
  filter(species_code %in% amphs$species_code) %>%
  select(location, recording_date_time, species_code, individual_count) %>%
  distinct()

amphs_only %>%
  mutate(individual_count = as.numeric(gsub('CI ','',individual_count)),
         julian = lubridate::yday(recording_date_time),
         year = lubridate::year(recording_date_time),
         recording_date_time = as.Date(recording_date_time)) %>%
  filter(species_code %in% c("GRFG","SPPE")) %>%
  ggplot(.,
       aes(x = julian, y = species_code, fill = species_code)) + 
  geom_density_ridges(scale = 0.3, bandwith = 0.1) + 
  scale_fill_viridis_d() +
  labs(title = "Activity per location", x = "Location", y = "Species") +
  theme_bw() +
  facet_wrap(~year)

```

------------------------------------------------------------------------

# Discussion

Considering the recent (2022) natural disturbance effects seen in the Park, species richness and diversity stayed relatively stable. Individuals nesting in conifer dominant stands likely moved to more suitable habitat outside the park, suggesting the potential utility of metapopulation analysis through passive acoustic monitoring outside of the park via citizen science participation. 

Further analysis may utilize dynamic occupancy models (@mackenzie2009), multi-species multi-season occupancy models (@devarajan2020multi), or community shifts (@oksanen2010canonical) to describe richness and diversity while accounting for decreases in species that may rely on specific habitat structures within the park. Additional geospatial assets could improve the accuracy of modelling apporaches as well. Nevertheless, this study demostrates the efficacy of autonomous recording units (ARUs) as a powerful tool for monitoring climatic and habitat shifts with a relatively low sample size and area coverage. As Avian species within the Park forest demonstrate a non-uniform distribution relative to habitat, the following recommendations for optimizing the efficiency and reliability of the ARU program include:

-   Prioritizing monitoring of historical locations, particularly emphasizing repeats at `r repeats` as baselines for evaluating ecological changes over time.
-   Adjusting monitoring times to dawn and dusk and extending deployment periods to 4-7 days between May 15 and July 15 to maximize vocalizations during peak activity periods.
-   Regular servicing of ARUs, focusing on testing microphone sensitivity degradation to ensure optimal functionality, data reliability, and longevity.
-   Continuing high-quality verification of tags to create annotated datasets for building and automating classifiers within WildTrax.
- Data publication WildTrax can further the dissemination of information and participation of others in the park network
